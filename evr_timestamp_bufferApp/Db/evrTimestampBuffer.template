# AI to start processing the TDC timestamp
record(ai, "$(SYS)$(DRIVEID)TDCProc")
{
    field(DESC, "Start processing the TDC record")
    field(INP,  "$(TDC_EVENT_LINK) CPP")
    field(FLNK, "$(SYS)$(DRIVEID)TDC_Epics.PROC")
}

# Convert revolution interrupt timestamp from chopper to double
record(ai, "$(SYS)$(DRIVEID)TDC_Epics")
{
    field(DESC, "EPICS epoch TDC timestamp")
    field(TSEL, "$(TDC_EVENT_LINK).TIME")
    field(DTYP, "Soft Timestamp")
    field(FLNK, "$(SYS)$(DRIVEID)TDC_Unix_stringin.PROC")
}

# Convert revolution interrupt timestamp from chopper to double
record(stringin, "$(SYS)$(DRIVEID)TDC_Unix_stringin")
{
    field(DESC, "Timestamp of the TDC")
    field(INP,  "@%s.%09f")
    field(TSEL, "$(TDC_EVENT_LINK).TIME")
    field(DTYP, "Soft Timestamp")
    field(FLNK, "$(SYS)$(DRIVEID)TDC_Unix_asub")
}

# TDC timestamp
record(aSub, "$(SYS)$(DRIVEID)TDC_Unix_asub")
{
    field(DESC, "Timestamp with unix epoch seconds (A) and nanoseconds (B)")
    field(SNAM, "nano_second_timestamp")
    field(INPA, "$(TDC_EVENT_LINK)")
    field(FTVA, "LONG")
    field(FTVB, "LONG")
    field(FTVC, "LONG")
    field(FTVD, "INT64")
    field(NOVA, "1")
    field(FLNK, "$(SYS)$(DRIVEID)TDC_Unix.PROC")
}

# Unix Epoch TDC
record(ai, "$(SYS)$(DRIVEID)TDC_Unix")
{
    field(DESC, "Unix epoch TDC timestamp")
    field(INP,  "$(SYS)$(DRIVEID)TDC_Unix_stringin")
    field(DTYP, "Soft Channel")
    field(FLNK, "$(SYS)$(DRIVEID)TS_Array_sec")
}

# AI to start processing the beam pulse timestamp
record(ai, "$(SYS)$(DRIVEID)RefProc")
{
    field(DESC, "Start processing the beampulse record")
    field(INP,  "$(BEAMPULSE_EVENT_LINK) CPP")
    field(FLNK, "$(SYS)$(DRIVEID)Ref_Epics.PROC")
}

# AI to convert Ref timestamp to value
record(ai, "$(SYS)$(DRIVEID)Ref_Epics")
{
    field(DESC, "Timestamp of the beam pulse")
    field(TSEL,  "$(BEAMPULSE_EVENT_LINK).TIME")
    field(DTYP, "Soft Timestamp")
    field(FLNK, "$(SYS)$(DRIVEID)Ref_Unix_stringin.PROC")
}

record(stringin, "$(SYS)$(DRIVEID)Ref_Unix_stringin")
{
    field(DESC, "Timestamp of the Ref")
    field(INP,  "@%s.%09f")
    field(TSEL, "$(BEAMPULSE_EVENT_LINK).TIME")
    field(DTYP, "Soft Timestamp")
    field(FLNK, "$(SYS)$(DRIVEID)Ref_Unix_asub.PROC")
}

# Beampulse timestamp
# Needs forward link from softEvent template of beam pulse event.
record(aSub, "$(SYS)$(DRIVEID)Ref_Unix_asub")
{
    field(DESC, "Timestamp in nano seconds")
    field(SNAM, "nano_second_timestamp")
    field(INPA, "$(BEAMPULSE_EVENT_LINK)")
    field(FTVA, "LONG")
    field(FTVB, "LONG")
    field(FTVC, "LONG")
    field(FTVD, "INT64")
    field(NOVA, "1")
    field(FLNK, "$(SYS)$(DRIVEID)Ref_Unix.PROC")
}

# Beampulse timestamp
# Needs forward link from softEvent template of beam pulse event.
record(ai, "$(SYS)$(DRIVEID)Ref_Unix")
{
    field(DESC, "Timestamp of the beam pulse")
    field(INP,  "$(SYS)$(DRIVEID)Ref_Unix_stringin")
    field(DTYP, "Soft Channel")
    field(FLNK, "$(SYS)$(DRIVEID)BPFO")
}

# Beampulse fanout: store timestamp array in waveform
# then reset current timestamp array.
record(fanout, "$(SYS)$(DRIVEID)BPFO")
{
    field(LNK1, "$(SYS)$(DRIVEID)PulseTS_sec
    field(LNK2, "$(SYS)$(DRIVEID)PulseTS_nsec
    field(LNK2, "$(SYS)$(DRIVEID)RST_sec")
    field(LNK2, "$(SYS)$(DRIVEID)RST_nsec")
}

# Reset the timestamp array on beam pulse interrupt
record(bo, "$(SYS)$(DRIVEID)RST_sec)
{
    field(DESC, "Reset timestamp array")
    field(OUT,  "$(SYS)$(DRIVEID)TS_Array_sec.RES NPP")
}

# Reset the timestamp array on beam pulse interrupt
record(bo, "$(SYS)$(DRIVEID)RST_nsec")
{
    field(DESC, "Reset timestamp array")
    field(OUT,  "$(SYS)$(DRIVEID)TS_Array_nsec.RES NPP")
}

# Compress records used as circual buffer to store chopper timestamps 
# in between beam pulses.
# Note that TSARR_N has to be set strictly greater than chopper frequency
# divided by beam pulse frequency.
record(compress, "$(SYS)$(DRIVEID)TS_Array_sec")
{
    field(DESC, "Current chopper seconds array")
    field(NSAM, "$(TSARR_N)")
    field(ALG,  "Circular Buffer")
    field(INP,  "$(SYS)$(DRIVEID)TDC_Unix_asub.VALA")
    field(TSEL, "$(TDC_EVENT_LINK).TIME")
    field(FLNK, "$(SYS)$(DRIVEID)TS_Array_nsec")
}

record(compress, "$(SYS)$(DRIVEID)TS_Array_nsec")
{
    field(DESC, "Current chopper nanoseconds array")
    field(NSAM, "$(TSARR_N)")
    field(ALG,  "Circular Buffer")
    field(INP,  "$(SYS)$(DRIVEID)TDC_Unix_asub.VALB")
    field(TSEL, "$(TDC_EVENT_LINK).TIME")
}

# Final timestamp array from chopper interrupt, 
# valid until next beampulse intterupt.
record(waveform, "$(SYS)$(DRIVEID)PulseTS_sec")
{
    field(DESC, "Chopper epoch seconds array during the last pulse")
    field(INP,  "$(SYS)$(DRIVEID)TS_Array NPP")
    field(FTVL, "DOUBLE")
    field(NELM, "$(TSARR_N)")
    field(TSEL, "$(BEAMPULSE_EVENT_LINK).TIME")
}
# Final timestamp array from chopper interrupt, 
# valid until next beampulse intterupt.
record(waveform, "$(SYS)$(DRIVEID)PulseTS_nsec")
{
    field(DESC, "Chopper nanoseconds array during the last pulse")
    field(INP,  "$(SYS)$(DRIVEID)TS_Array NPP")
    field(FTVL, "DOUBLE")
    field(NELM, "$(TSARR_N)")
    field(TSEL, "$(BEAMPULSE_EVENT_LINK).TIME")
}
